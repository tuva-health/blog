<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Aaron Neiderhiser">
<meta name="dcterms.date" content="2024-04-17">

<title>Building a Claims Data Platform – The Tuva Project Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The Tuva Project Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Building a Claims Data Platform</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">claims</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Aaron Neiderhiser </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 17, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>The last few years have seen a dramatic increase in the number of organizations delivering and enabling value-based care. This in turn has led to an increase in the availability of healthcare claims data, as claims data is often shared across organizations participating in value-based contracts. As a result, more organizations are looking for smart ways to manage their claims data.</p>
<p>A claims data platform is designed to do just that: aggregate, harmonize, and analyze claims datasets. Building a claims data platform is complex because it requires specialized knowledge about how to manage a bunch of idiosyncratic data issues specific to claims.</p>
<p>Recently, I’ve had a number of people ask me for advice about building a claims data platform. I’ve built a number of claims data platforms over the years for payers, ACOs, and tech companies. And I’ve made a ton of mistakes and learned a lot in the process.</p>
<p>This blog post covers the key things to consider when building a claims data platform. We also discuss how we solve some of these problems at Tuva. Hopefully you’ll be able to avoid some of the mistakes we’ve made in the past by thinking these things through up front.</p>
<p>In particular we discuss the following:</p>
<ul>
<li>Technology Stack</li>
<li>Data Acquisition</li>
<li>Adjustments, Denials, and Reversals</li>
<li>Data Quality</li>
<li>Common Data Model</li>
<li>Groupers</li>
<li>Measures</li>
<li>Risk Models</li>
</ul>
<section id="technology-stack" class="level2">
<h2 class="anchored" data-anchor-id="technology-stack">Technology Stack</h2>
<p>The tech stack you choose has nothing specifically to do with claims data, but is essential nonetheless. I’ll share my opinion here but the truth is that it’s hard to go wrong with the options available today - as long as you keep it simple. Any cloud vendor is fine and there are only a few key components:</p>
<ul>
<li>SFTP</li>
<li>Cloud Storage</li>
<li>Data Warehouse</li>
<li>Data Transformation</li>
<li>Data Visualization</li>
</ul>
<p>I’ll share a few brief comments on each one.</p>
<p><strong>SFTP:</strong> It doesn’t particularly matter what software you use. Just know that claims data is commonly transmitted as flat files (e.g.&nbsp;CSV, tab delimited, fixed-width, etc.) and payers and health plans are used to sharing the files via SFTP.</p>
<p><strong>Cloud Storage:</strong> This is basic storage for files that is accessible as part of any public cloud subscription e.g.&nbsp;AWS S3, Google Cloud Storage, Azure Blob Storage, etc. This is where you’ll store the files after they arrive via SFTP. You may also be able to convince your claims data provider to upload files directly to cloud storage.</p>
<p><strong>Data Warehouse:</strong> As of this writing, 3 data warehouses are the most popular: Snowflake, Databricks, and Google Bigquery. There are many, many others, but if you’re unsure what to choose I <strong>highly</strong> advise you don’t over-think it and go with one of these three. We primarily use Snowflake at Tuva. It’s incredibly simple to use and surprisingly cheap - our total bill was only a few hundred dollars per month for the first couple years and even now that we’ve grown quite a bit we’re only up to $10-15,000 per year.</p>
<p><strong>Data Transformation:</strong> Here the answer is easier: <a href="intro-dbt-for-healthcare">dbt</a>.</p>
<p><strong>Data Visualization:</strong> Again, there are many options, with a couple leading the pack: Power BI, Tableau, and Looker. At Tuva we primarily use Power BI. Choose whichever tool you’re familiar with and your team has experience with.</p>
<p>You can find endless articles detailing the pros and cons of each of these options, so I won’t spend any more time on them here.</p>
</section>
<section id="data-acquisition" class="level2">
<h2 class="anchored" data-anchor-id="data-acquisition">Data Acquisition</h2>
<p>Getting payers, health plans, and employers (not to mention brokers and TPAs) to share the right claims data with you is surprisingly tricky. Ideally you get it right the first time and avoid extensive back and forth that can easily drag on for months.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="you-shall-not-access.jpg" class="img-fluid figure-img"></p>
<figcaption>Gandolf</figcaption>
</figure>
</div>
<p>It’s common for data providers to only share a subset of available data based on what they feel is necessary or important. It’s on you to pushback and negotiate when you don’t get the fields that you need. And this is difficult to do without a granular understanding of which fields are required for which use cases.</p>
<p>For example, is bill_type_code important? Which use cases (e.g.&nbsp;metrics) can’t I pursue if I don’t get this field? These are the types of questions you’ll need to think through and be able to answer.</p>
<p>It’s a good practice to provide a data dictionary to your data provider to let them know the data you’re looking for. If you’re planning to use Tuva can you share the data dictionary for the <a href="https://thetuvaproject.com/connectors/input-layer">Tuva Input Layer</a>. It’s a pretty standard, normal looking claims data model. In certain cases the data provider will send you the data already in this format.</p>
</section>
<section id="adjustments-denials-and-reversals" class="level2">
<h2 class="anchored" data-anchor-id="adjustments-denials-and-reversals">Adjustments, Denials, and Reversals</h2>
<p>It’s common for claims to be adjusted, denied, or reversed if there was a problem with how the claim was originally submitted. For most analytics use cases you want to deal with final action claims and not any of these intermediary claims. If you don’t have a method for identifying and flagging adjustments, denials, and reversals it can throw off your analytics.</p>
<p>We provide a longer discussion of claim adjustments, denials, and reversals, including tips for how to identify them <a href="https://knowledge.thetuvaproject.com/claims-adr">here</a>. However to briefly summarize there are two approaches you should take.</p>
<p>First, ask your claims data provider how you should identify these intermediary claims in the dataset they give you. Payers and health plans are often good about providing this info. However, in our experience it’s usually only accurate 25% of the time.</p>
<p>Second, if you weren’t able to get any info from the payer or health plan, or if the info they provided wasn’t accurate, then you have to figure it out yourself. This boils down to figuring out which claims are related based on dates, member IDs, claim IDs, paid amounts, etc. Our guide in the link above can provide some helpful tricks for how to do this.</p>
</section>
<section id="data-quality" class="level2">
<h2 class="anchored" data-anchor-id="data-quality">Data Quality</h2>
<p>If this is your first time working with claims data I have some unfornate news for you: Your claims data is going to have significant data quality problems that will impact the answers you derive from it. How significant they are is the question.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="morpheus.jpg" class="img-fluid figure-img"></p>
<figcaption>Morpheus</figcaption>
</figure>
</div>
<p>There are two types of things you will want to analyze from a data quality standpoint. First, you’ll want to assess what I call “atomic-level” data quality issues. These are issues that occur when the raw data doesn’t look like it should. Examples of atomic-level data quality problems include:</p>
<ul>
<li>bill_type_code is missing on a line of an institutional claim (every institutional claim line should have a bill_type_code)</li>
<li>bill_type_code is invalid (there are only certain values it should take)</li>
<li>bill_type_code is duplicated (there should be one and only one per institutional claim)</li>
</ul>
<p>There are hundreds of checks like this that are specific to claims that you will want to check for.</p>
<p>Second, you’ll want to analyze the impact of data quality issues on use cases. For example, if there is a problem with bill_type_code that will impact the definition of acute inpatient visits, which will impact metrics like length of stay, readmission rate, and mortality.</p>
<p>We’ve built this sort of analytics in a product we call Data Quality Intelligence as an add-on to the open-source.</p>
</section>
<section id="common-data-model" class="level2">
<h2 class="anchored" data-anchor-id="common-data-model">Common Data Model</h2>
<p>If you’re acquiring claims data from multiple data partners these datasets are likely (i.e.&nbsp;pretty much guaranteed) to be in completely different formats. In order to run your analytics using one code base you’ll need to harmonize the different formats into a common data model.</p>
<p>Here are the main things you’ll want to consider when choosing a common data model:</p>
<ol type="1">
<li>Mapping</li>
<li>Use Cases</li>
<li>Customization</li>
</ol>
<p><strong>Mapping:</strong> You’ll want to make sure that your data model is easy to map claims data sources to. Mapping means transforming data from one data model into another. How similar your data model is to the data sources you get from your data partners determines how easy it is to map data. Do you have separate medical claims and pharmacy claims tables, or just one claims table? Do you separate header and line information into separate tables? Is enrollment represented as spans or member months?</p>
<p><strong>Use Cases:</strong> Some common data models are designed for specific types of analytics. For example, the <a href="https://ohdsi.github.io/CommonDataModel/">OMOP</a> common data model is designed with clinical research use cases in mind. You’ll want to make sure the data model you choose powers the use cases you care about.</p>
<p><strong>Customization:</strong> You are going to have use cases that are somewhat to unique to your organization. There is no perfect data model. Make sure you choose a data model that you’re able to modify to meet your unique needs.</p>
<p>The <a href="https://thetuvaproject.com/core-data-model/overview">Core Data Model</a> is the common data model in Tuva. It’s designed for both claims and clinical data sources and use cases.</p>
</section>
<section id="groupers" class="level2">
<h2 class="anchored" data-anchor-id="groupers">Groupers</h2>
<p>Claims data is made up of hundreds of thousands of codes representing conditions, services, procedures, medical devices, drugs, facilities, providers, etc. It’s very difficult to analyze information that is high-cardinality like this.</p>
<p>Groupers have been around for decades solving this problem. As you might guess, groupers “group” claims into higher-level categories, making them easier to analyze. There are a couple of groupers that are really important for analyzing claims data.</p>
<ul>
<li>Service Categories</li>
<li>Encounters</li>
<li>Conditions</li>
<li>Procedures</li>
</ul>
<p><strong>Service Categories:</strong> <a href="https://knowledge.thetuvaproject.com/service-categories">Service categories</a> group claims into higher-level categories related to the type of service the claim was related to. For example, was the claim inpatient, outpatient, or an office visit? Very often service categories are used to stratify spend and utilization.</p>
<p><strong>Encounters:</strong> It’s very common for certain types of visits (especially inpatient) to be billed as multiple claims, one for the facility and one for the physician. In order to perform analysis at the visit level, these claims must be grouped together. <a href="https://knowledge.thetuvaproject.com/encounters">Encounter Types</a> is where claims are grouped into encounters in Tuva.</p>
<p><strong>Conditions:</strong> ICD-10-CM codes make up the conditions in claims data. That’s more than 70,000 distinct codes. In order to efficiently analyze different patient populations you need to group these codes into higher-level disease categories e.g.&nbsp;type 2 diabetes, chronic kidney disease, atrial fibrillation, etc.</p>
<p><strong>Procedures:</strong> Similar to conditions there are thousands of ICD-10-PCS and HCPCS codes describing surgical procedures and other types of services delivered to patients and to do any type of meaningful analysis you need to consolidate these.</p>
</section>
<section id="measures" class="level2">
<h2 class="anchored" data-anchor-id="measures">Measures</h2>
<p>There are a few types of measures that are considered “table stakes” for value-based care analytics, meaning essentially everyone needs them. These are:</p>
<ol type="1">
<li>Spend and Utilization</li>
<li>Quality Measures</li>
<li>Acute Events</li>
</ol>
<p><strong>Spend and Utilization:</strong> Analyzing the cost and volume of care delivered to your patient population is likely one of your key analytics use cases. Most often these metrics are normalized for the enrolled population, i.e.&nbsp;calculated on a per-member-per-month or PMPM basis. Service categories are commonly used in this type of analysis to allow for drill-down into categories that may be accountable for large or above benchmark increases in spend and utilization.</p>
<p><strong>Quality Measures:</strong> Quality Measures are almost always part of value-based contracts. There are hundreds of measures, maintained by different organizations, and updated on different schedules. Each measure includes logic and value sets to calculate it.</p>
<p><strong>Acute Events:</strong> The hallmark of value-based care is moving care that can be provided in lower acuity settings (e.g.&nbsp;urgent care) out of the hospital. Therefore being able to analyze events like acute inpatient and emergency department visits and their related metrics, e.g.&nbsp;readmissions and potentially preventable events, is extremely important.</p>
</section>
<section id="risk-models" class="level2">
<h2 class="anchored" data-anchor-id="risk-models">Risk Models</h2>
<p>Risk adjustment and risk stratification models are also considered “table stakes” for value-based care analytics. These are two related but different concepts:</p>
<p><strong>Risk adjustment:</strong> Allows you to adjust for differences in your patient population, e.g.&nbsp;age, gender, health status, disease burden, so that you can trend, compare, and benchmark metrics over time. Think of risk adjustment as enabling “apples to apples” analytics.</p>
<p><strong>Risk stratification:</strong> Allows you to predict events that are going to happen in the future, e.g.&nbsp;which patients are at high-risk for a hospitalization or death.</p>
<p>The are a number of publicly available risk models, include CMS-HCCs, which are part of Tuva. There are also a large number of proprietary risk models.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Hopefully the discussion above was helpful and you learned something. Or if you have a better way to think about it I would love to talk to you. But there is one final piece of advice that is most important which I’ll leave you with.</p>
<p>The most common failure-mode I see is a ton of time and effort spent setting up technology and transforming data that doesn’t result in the generation of important insights. Often this is because the people setting up the technology and transforming the data are disconnected from the data analysts actually trying to answer the questions. To avoid this do the following:</p>
<ol type="1">
<li><p>Write down your most use cases and be specific. For example, we want to analyze these 10 quality measures (list them) and want to flag patients that are in the denominator but not the numerator (i.e.&nbsp;have a care gap).</p></li>
<li><p>From each use case, work backwards to identify the data tables and columns that are needed to do the analysis. In the example above, is there a data table that calculates the quality measure performance by measure and another data table at the patient grain that includes the patients that meet denominator criteria but not numerator?</p></li>
<li><p>Work backwards from the analysis-ready data tables to determine the raw claims data elements that are needed to do the analysis.</p></li>
</ol>
<p>If you spend the time following this exercise and build your data platform accordingly, I pretty much guarantee you’ll avoid wasting time and resources building a claims data platform no one uses and everyone hates :-)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>